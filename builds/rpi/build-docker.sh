#!/usr/bin/env bash
set -euo pipefail

# Build a Raspberry Pi image inside a Docker container.
# Works on macOS, Windows (WSL), and Linux — no native arm64 Debian host needed.
#
# Requires: Docker Desktop (or Docker Engine on Linux)
# The container runs with --privileged for mmdebstrap (needs full POSIX
# filesystem ops: mknod, chroot, mount, etc.).
#
# The entire build happens inside the container's own filesystem — no host
# bind mounts for output. This avoids virtiofs/gRPC-FUSE limitations on macOS
# (broken symlinks, permission errors, missing temp dirs). After the build
# finishes, the .img file is extracted to the host via `docker cp`.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
IMAGE_NAME="catalyst-rpi-builder"
IMAGE_TAG="latest"
SOURCE_DIR=""
BUILD_DIR=""
CONFIG_FILE=""
CLONE_BRANCH="master"
REBUILD_IMAGE=false

# ---------- Usage ----------

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] <config.yaml>

Build a Raspberry Pi image using Docker (works on macOS, Linux, Windows).

This wraps rpi-image-gen inside a Debian arm64 container so you don't need
a native arm64 Debian host. On Apple Silicon Macs the build runs natively;
on Intel hosts it uses QEMU emulation (slower but functional).

The config YAML is typically generated by the catalyst-rpi-config CLI:
  bun run rpi:config -- --non-interactive --password p --peering-secret s

Arguments:
  <config.yaml>                Path to the rpi-image-gen config YAML

Options:
  --source-dir <path>          Source directory (from catalyst-rpi-config output)
                               (default: builds/rpi/ next to this script)
  --build-dir <path>           Build output directory for the .img file
                               (default: <source-dir>/build)
  --branch <branch>            rpi-image-gen branch to clone (default: master)
  --rebuild                    Force rebuild of the Docker image
  -h, --help                   Show this help

Requirements:
  - Docker Desktop (or Docker Engine on Linux)
  - ~6 GB free disk space (Docker image + build artifacts)

Examples:
  # Generate config, then build via Docker
  bun run rpi:config -- --non-interactive --password p --peering-secret s
  ./builds/rpi/build-docker.sh --source-dir dist/rpi dist/rpi/config.yaml

  # Specify a custom build output directory
  ./builds/rpi/build-docker.sh \\
    --build-dir /tmp/rpi-build \\
    --source-dir dist/rpi \\
    dist/rpi/config.yaml

  # Force rebuild of the Docker image (e.g. to pick up rpi-image-gen updates)
  ./builds/rpi/build-docker.sh --rebuild --source-dir dist/rpi dist/rpi/config.yaml

EOF
  exit 0
}

# ---------- Argument parsing ----------

while [[ $# -gt 0 ]]; do
  case $1 in
    --source-dir)     SOURCE_DIR="$2"; shift 2;;
    --build-dir)      BUILD_DIR="$2"; shift 2;;
    --branch)         CLONE_BRANCH="$2"; shift 2;;
    --rebuild)        REBUILD_IMAGE=true; shift;;
    -h|--help)        usage;;
    -*)               echo "Unknown option: $1"; echo ""; usage;;
    *)
      if [[ -z "$CONFIG_FILE" ]]; then
        CONFIG_FILE="$1"; shift
      else
        echo "ERROR: Unexpected argument: $1"
        echo "Only one config file can be specified."
        exit 1
      fi
      ;;
  esac
done

if [[ -z "$CONFIG_FILE" ]]; then
  echo "ERROR: No config YAML specified."
  echo ""
  usage
fi

if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "ERROR: Config file not found: $CONFIG_FILE"
  exit 1
fi

# ---------- Resolve paths ----------

CONFIG_FILE="$(cd "$(dirname "$CONFIG_FILE")" && pwd)/$(basename "$CONFIG_FILE")"
SOURCE_DIR="${SOURCE_DIR:-$SCRIPT_DIR}"
SOURCE_DIR="$(cd "$SOURCE_DIR" && pwd)"

if [[ -z "$BUILD_DIR" ]]; then
  BUILD_DIR="${SOURCE_DIR}/build"
fi
mkdir -p "$BUILD_DIR"
BUILD_DIR="$(cd "$BUILD_DIR" && pwd)"

# ---------- Docker checks ----------

check_docker() {
  if ! command -v docker &>/dev/null; then
    echo "ERROR: Docker is not installed or not in PATH."
    echo ""
    echo "  Install Docker Desktop: https://www.docker.com/products/docker-desktop/"
    exit 1
  fi

  if ! docker info &>/dev/null; then
    echo "ERROR: Docker daemon is not running."
    echo ""
    echo "  Start Docker Desktop and try again."
    exit 1
  fi
}

# ---------- Build Docker image ----------

build_image() {
  local needs_build=false

  if [[ "$REBUILD_IMAGE" == true ]]; then
    needs_build=true
  elif ! docker image inspect "${IMAGE_NAME}:${IMAGE_TAG}" &>/dev/null; then
    needs_build=true
  fi

  if [[ "$needs_build" == true ]]; then
    echo "=== Building Docker Image ==="
    echo "  Image:  ${IMAGE_NAME}:${IMAGE_TAG}"
    echo "  Branch: ${CLONE_BRANCH}"
    echo ""
    echo "  This is a one-time operation (~2-5 min). Subsequent builds use cache."
    echo ""

    docker build \
      --platform linux/arm64 \
      -t "${IMAGE_NAME}:${IMAGE_TAG}" \
      --build-arg "RPI_IMAGE_GEN_BRANCH=${CLONE_BRANCH}" \
      -f "${SCRIPT_DIR}/Dockerfile.build" \
      "${SCRIPT_DIR}"

    echo ""
    echo "Docker image ready: ${IMAGE_NAME}:${IMAGE_TAG}"
  else
    echo "Docker image '${IMAGE_NAME}:${IMAGE_TAG}' found (use --rebuild to force)"
  fi
  echo ""
}

# ---------- Run build ----------

run_build() {
  # Determine how to mount the config file
  local config_container_path
  local -a extra_mounts=()

  if [[ "$CONFIG_FILE" == "$SOURCE_DIR"/* ]]; then
    # Config is inside source dir — accessible via the source mount
    local rel="${CONFIG_FILE#"$SOURCE_DIR"/}"
    config_container_path="/src/${rel}"
  else
    # Config is outside source dir — mount it separately
    config_container_path="/config.yaml"
    extra_mounts+=(-v "${CONFIG_FILE}:/config.yaml:ro")
  fi

  # Named container (no --rm) so we can docker cp results out after it exits.
  # PID suffix avoids collisions if multiple builds run concurrently.
  local container_name="catalyst-rpi-build-$$"

  echo "=== Running Build in Docker ==="
  echo "  Source dir:  ${SOURCE_DIR} → /src (read-only)"
  echo "  Config:      $(basename "$CONFIG_FILE") → ${config_container_path}"
  echo "  Output dir:  ${BUILD_DIR}"
  echo "  Container:   ${container_name}"
  echo ""
  echo "  Build runs entirely inside the container (no host bind mounts for output)."
  echo "  The .img file will be extracted via docker cp when the build finishes."
  echo ""

  # Run the build with retry logic. Transient apt mirror issues (hash-sum
  # mismatches from CDN sync races) are common with archive.raspberrypi.com.
  # Between attempts we clean apt caches and refresh indices.
  local max_retries=3
  local build_exit=0

  for attempt in $(seq 1 "$max_retries"); do
    build_exit=0

    if [[ "$attempt" -gt 1 ]]; then
      echo ""
      echo "=== Retry ${attempt}/${max_retries}: cleaning caches and refreshing indices ==="
      echo ""
      # Remove the failed container so we can reuse the name
      docker rm "${container_name}" >/dev/null 2>&1 || true
      sleep 5
    fi

    docker run \
      --name "${container_name}" \
      --platform linux/arm64 \
      --privileged \
      -v "${SOURCE_DIR}:/src:ro" \
      ${extra_mounts[@]+"${extra_mounts[@]}"} \
      "${IMAGE_NAME}:${IMAGE_TAG}" \
      /bin/bash -c '
        # Refresh apt indices to avoid stale hash mismatches from CDN sync
        apt-get update -qq 2>/dev/null || true

        /opt/rpi-image-gen/rpi-image-gen build \
          -S /src \
          -c "'"${config_container_path}"'" \
          -B /build/output
        build_rc=$?
        find /build/output -name "*.img" -type f > /build/output/.img-manifest 2>/dev/null || true
        exit $build_rc
      ' || build_exit=$?

    if [[ "$build_exit" -eq 0 ]]; then
      break
    fi

    if [[ "$attempt" -lt "$max_retries" ]]; then
      echo ""
      echo "WARNING: Build attempt ${attempt} failed (exit code ${build_exit})."
      echo "  This may be a transient apt mirror issue. Retrying..."
    fi
  done

  # --- Handle build failure ---
  if [[ "$build_exit" -ne 0 ]]; then
    echo ""
    echo "ERROR: Build failed after ${max_retries} attempts (exit code ${build_exit})."
    echo ""
    echo "  The build container has been kept for debugging:"
    echo "    docker logs ${container_name}        # view full build log"
    echo "    docker rm ${container_name}           # clean up when done"
    echo ""
    echo "  If the error is 'Hash Sum mismatch', the Raspberry Pi apt mirror"
    echo "  may be temporarily out of sync. Wait 15-30 minutes and try again."
    echo ""
    # Don't remove the container — leave it for inspection
    exit "$build_exit"
  fi

  # --- Extract .img files via docker cp ---
  echo ""
  echo "=== Extracting build artifacts ==="

  # Pull the manifest that lists .img paths inside the container
  docker cp "${container_name}:/build/output/.img-manifest" "${BUILD_DIR}/.img-manifest" 2>/dev/null || true

  local found_img=false
  if [[ -f "${BUILD_DIR}/.img-manifest" ]]; then
    while IFS= read -r img_path; do
      if [[ -n "$img_path" ]]; then
        local img_name
        img_name="$(basename "$img_path")"
        echo "  ${img_name}..."
        docker cp "${container_name}:${img_path}" "${BUILD_DIR}/${img_name}"
        found_img=true
      fi
    done < "${BUILD_DIR}/.img-manifest"
    rm -f "${BUILD_DIR}/.img-manifest"
  fi

  # Clean up the build container
  docker rm "${container_name}" >/dev/null 2>&1 || true

  if [[ "$found_img" == false ]]; then
    echo ""
    echo "ERROR: Build succeeded but no .img file was found."
    echo "  This may indicate an rpi-image-gen configuration issue."
    exit 1
  fi
}

# ---------- Post-build ----------

print_results() {
  echo ""
  echo "=== Build Complete ==="
  echo ""

  # Find .img files in the build directory
  local found=false
  while IFS= read -r img_file; do
    if [[ -n "$img_file" ]]; then
      local size
      size="$(du -h "$img_file" 2>/dev/null | cut -f1)"
      echo "  Image: ${img_file} (${size})"
      found=true
    fi
  done < <(find "$BUILD_DIR" -name '*.img' -type f 2>/dev/null)

  if [[ "$found" == false ]]; then
    echo "  Build dir: $BUILD_DIR"
    echo "  (Check the build output above for the exact image path)"
  fi

  echo ""
  echo "  To flash to an SD card:"
  echo ""
  echo "    # macOS (requires Raspberry Pi Imager — https://www.raspberrypi.com/software/):"
  echo "    #   1. Find your SD card device:  diskutil list"
  echo "    #   2. Flash (replace diskN with your SD card):"
  echo "    /Applications/Raspberry\\ Pi\\ Imager.app/Contents/MacOS/rpi-imager --cli \\"
  echo "      <image>.img /dev/rdiskN"
  echo ""
  echo "    # Linux:"
  echo "    sudo rpi-imager --cli <image>.img /dev/sdX"
  echo ""
}

# ---------- Main ----------

main() {
  echo ""
  echo "  Catalyst Node — RPi Image Builder (Docker)"
  echo ""

  check_docker
  build_image
  run_build
  print_results
}

main
