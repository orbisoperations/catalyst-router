import { Document, isMap, isPair, isScalar, type YAMLMap } from 'yaml'
import type { RpiImageGenConfig, ResolvedOptions } from './types.js'

/** Section-level comments (commentBefore on section keys) */
const SECTION_COMMENTS: Record<string, string> = {
  include: 'Base OS: Debian 12 (Bookworm) minimal with systemd, apt, SSH',
  device: 'Target device and login credentials',
  image: 'Disk image layout',
  layer:
    'Layers to include in the build.\n' +
    'Each entry pulls in a layer YAML and its transitive dependencies.\n' +
    'Remove a line to exclude that feature from the image.',
  docker: 'Docker: add the build user to the docker group',
  ssh: 'SSH: public key authentication only (password auth disabled)',
  wifi:
    'WiFi network configuration.\n' +
    'Credentials are written to /etc/wpa_supplicant/wpa_supplicant-wlan0.conf',
  otel:
    'OpenTelemetry Collector version.\n' +
    'Binary downloaded from github.com/open-telemetry/opentelemetry-collector-releases',
  catalyst: 'Catalyst Node settings. See: catalyst-node --help for all options',
  cloudflared:
    'Cloudflare Tunnel for remote SSH access.\n' +
    'Token from: Cloudflare Zero Trust dashboard > Networks > Tunnels',
}

/** Inline comments (comment on scalar values) */
const INLINE_COMMENTS: Record<string, Record<string, string | ((val: string) => string)>> = {
  device: {
    layer: (device: string) => {
      const labels: Record<string, string> = {
        rpi5: 'Hardware: Raspberry Pi 5',
        pi4: 'Hardware: Raspberry Pi 4',
        cm5: 'Hardware: Compute Module 5',
        cm4: 'Hardware: Compute Module 4',
        zero2w: 'Hardware: Raspberry Pi Zero 2 W',
      }
      return labels[device] ?? `Hardware: ${device}`
    },
    user1: 'Login username',
    user1pass: 'Login password (change after first boot)',
  },
  image: {
    layer: 'Standard MBR boot + root partition',
  },
  layer: {
    otel: 'OpenTelemetry Collector (native binary)',
    app: 'Catalyst Node composite server',
    container: 'Docker CE engine (built-in layer)',
    wifi: 'WiFi (wpa_supplicant + systemd-networkd)',
    tunnel: 'Cloudflare Tunnel for remote SSH',
  },
  wifi: {
    country: 'ISO 3166-1 alpha-2 regulatory code',
  },
  catalyst: {
    node_id: 'Unique identifier (auto-generated on first boot if empty)',
    peering_secret: 'iBGP peering shared secret',
    domains: 'Comma-separated trusted domains',
    port: 'Composite server listen port',
    bootstrap_token: 'Initial auth bootstrap token',
    log_level: 'debug, info, warn, error',
    registry: 'Docker registry for catalyst images',
    tag: 'Container image tag',
  },
}

export function renderYaml(config: RpiImageGenConfig, opts: ResolvedOptions): string {
  const doc = new Document(config)
  const rootMap = doc.contents as YAMLMap

  // File header comment
  const features = [
    config.layer.wifi ? 'WiFi: yes' : null,
    config.layer.tunnel ? 'Cloudflared: yes' : null,
  ]
    .filter(Boolean)
    .join(' | ')

  doc.commentBefore = [
    ` Generated by catalyst-rpi-config v1.0.0`,
    ` Mode: ${opts.mode} | Device: ${opts.device}${features ? ` | ${features}` : ''}`,
    ` Re-run \`catalyst-rpi-config\` to regenerate, or edit this file directly.`,
  ].join('\n')

  // Attach section comments
  if (isMap(rootMap)) {
    for (const pair of rootMap.items) {
      if (isPair(pair) && isScalar(pair.key)) {
        const sectionName = String(pair.key.value)
        const sectionComment = SECTION_COMMENTS[sectionName]
        if (sectionComment) {
          pair.key.commentBefore = ` ${sectionComment}`
          pair.key.spaceBefore = true
        }

        // Attach inline comments to scalar values within sections
        const inlines = INLINE_COMMENTS[sectionName]
        if (inlines && isMap(pair.value)) {
          for (const innerPair of (pair.value as YAMLMap).items) {
            if (isPair(innerPair) && isScalar(innerPair.key) && isScalar(innerPair.value)) {
              const key = String(innerPair.key.value)
              const commentOrFn = inlines[key]
              if (typeof commentOrFn === 'function') {
                innerPair.value.comment = ` ${commentOrFn(String(innerPair.value.value))}`
              } else if (typeof commentOrFn === 'string') {
                innerPair.value.comment = ` ${commentOrFn}`
              }
            }
          }
        }
      }
    }
  }

  return doc.toString({ lineWidth: 0 })
}
